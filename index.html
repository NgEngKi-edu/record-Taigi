<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>éŒ„éŸ³ä½œæ¥­ç¹³äº¤</title>
  <style>
    :root{
      --ink:#111827;--muted:#6B7280;--line:#E5E7EB;--card:#fff;--bg:#F6FBFF;
      --blue:#1D4ED8;--green:#16A34A;--red:#EF4444;--yellow:#F59E0B;
      --shadow:0 12px 30px rgba(17,24,39,.12);--r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;padding:18px;
      background:
        radial-gradient(900px 420px at 20% 0%, #E0F2FE 0%, transparent 60%),
        radial-gradient(800px 420px at 90% 10%, #DCFCE7 0%, transparent 60%),
        var(--bg);
      color:var(--ink);
      font-family:"Microsoft JhengHei",system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif;
    }
    .wrap{max-width:880px;margin:0 auto;}
    .brand{display:flex;align-items:center;gap:12px;margin:8px 0 14px;}
    .logo{
      width:44px;height:44px;border-radius:14px;
      background:linear-gradient(135deg,#1D4ED8 0%,#16A34A 100%);
      box-shadow:0 10px 18px rgba(29,78,216,.18);
    }
    h1{margin:0;font-size:20px}
    .subt{color:var(--muted);font-size:13px;margin-top:2px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:14px;align-items:start}
    @media (max-width:820px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow);padding:16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:999px;border:1px solid var(--line);background:#F9FAFB;font-size:13px;color:var(--muted)}
    .dot{width:10px;height:10px;border-radius:999px;background:#9CA3AF;box-shadow:0 0 0 4px rgba(156,163,175,.18)}
    .dot.ok{background:var(--green);box-shadow:0 0 0 4px rgba(22,163,74,.16)}
    .dot.no{background:var(--red);box-shadow:0 0 0 4px rgba(239,68,68,.15)}
    .dot.wait{background:var(--yellow);box-shadow:0 0 0 4px rgba(245,158,11,.18)}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    select,input{width:100%;padding:12px 12px;border-radius:14px;border:1px solid var(--line);font-size:15px;outline:none;background:#fff}
    select:focus,input:focus{border-color:rgba(29,78,216,.5);box-shadow:0 0 0 4px rgba(29,78,216,.12)}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:520px){.two{grid-template-columns:1fr}}
    .btn{
      width:100%;padding:14px 16px;border:0;border-radius:16px;
      font-size:16px;font-weight:800;cursor:pointer;color:#fff;
      background:linear-gradient(135deg,#1D4ED8 0%,#2563EB 55%,#16A34A 120%);
      box-shadow:0 16px 26px rgba(29,78,216,.22);
      transition:transform .06s ease,filter .2s ease;
    }
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn[disabled]{opacity:.55;cursor:not-allowed;box-shadow:none}

    .meta{display:flex;flex-direction:column;align-items:stretch;margin-top:12px;gap:10px;}
    .status{width:100%;font-size:16px;color:var(--muted);line-height:1.5;}
    .status b{color:var(--ink)}
    .status .sub{display:block;margin-top:4px;font-size:14px;color:#6B7280}

    .timer{width:100%;display:flex;align-items:center;gap:10px;padding:12px 12px;border-radius:999px;background:#F3F4F6;border:1px solid var(--line);min-width:unset;}
    .bar{flex:1;height:10px;border-radius:999px;background:#E5E7EB;overflow:hidden}
    .bar > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#16A34A 0%,#22C55E 60%,#F59E0B 110%);border-radius:999px}
    .t{font-variant-numeric:tabular-nums;font-weight:900;min-width:54px;text-align:right;font-size:16px}

    .help{margin-top:10px;font-size:16px;color:var(--muted);line-height:1.6}
    .sbtn{border:1px solid var(--line);background:#fff;color:#111827;padding:10px 12px;border-radius:14px;font-weight:800;cursor:pointer;font-size:13px;display:inline-flex;align-items:center;gap:8px}
    .sbtn:active{transform:translateY(1px)}
    .smallBtnRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="brand">
    <div class="logo" aria-hidden="true"></div>
    <div>
      <h1 id="title">éŒ„éŸ³ä½œæ¥­</h1>
      <div class="subt">é¸ä½œæ¥­ â†’ å¡«åº§è™Ÿå§“å â†’ é–‹å§‹éŒ„éŸ³ï¼ˆçµæŸå¾Œé¡¯ç¤ºå›åŸ·é ï¼‰</div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between;margin-bottom:10px;">
        <div class="pill"><i class="dot wait" id="micDot"></i><span id="micText">éº¥å…‹é¢¨ç‹€æ…‹ï¼šå°šæœªæˆæ¬Š</span></div>
        <div class="pill"><span>éŒ„éŸ³æ ¼å¼ï¼š</span><b id="fmt">WAV (16kHz)</b></div>
      </div>

      <div class="label">é¸æ“‡ä½œæ¥­</div>
      <select id="taskSel"></select>

      <div class="two" style="margin-top:10px;">
        <div>
          <div class="label">åº§è™Ÿ</div>
          <input id="seatNo" inputmode="numeric" placeholder="ä¾‹ï¼š30" maxlength="2" />
        </div>
        <div>
          <div class="label">å§“å</div>
          <input id="stuName" placeholder="ä¾‹ï¼šç‹å°æ˜" maxlength="10" />
        </div>
      </div>

      <button class="btn" id="btn" style="margin-top:12px;" disabled>é–‹å§‹éŒ„éŸ³ä¸¦é€å‡º</button>

      <div class="meta">
        <div class="status" id="status">
          è¼‰å…¥ä½œæ¥­ä¸­â€¦
          <span class="sub">ç¬¬ä¸€æ¬¡æœƒè¦æ±‚éº¥å…‹é¢¨æ¬Šé™ï¼Œè«‹æŒ‰ã€Œå…è¨±ã€ã€‚</span>
        </div>

        <div class="timer">
          <div class="bar"><i id="bar"></i></div>
          <div class="t" id="t">00:00</div>
        </div>
      </div>

      <div class="smallBtnRow">
        <button class="sbtn" id="micTest">ğŸ¤ éº¥å…‹é¢¨æ¸¬è©¦</button>
        <button class="sbtn" id="help">ğŸ§© æ¬Šé™æ•™å­¸</button>
      </div>

      <div class="help">
        ä½¿ç”¨æ­¥é©Ÿï¼š1) é¸æ“‡ä½œæ¥­ã€€2) è¼¸å…¥åº§è™Ÿèˆ‡å§“åã€€3) æŒ‰ä¸‹é–‹å§‹éŒ„éŸ³ï¼ˆçµæŸå¾Œè‡ªå‹•é€å‡ºä¸¦é¡¯ç¤ºå›åŸ·é ï¼‰
      </div>
    </div>

    <div class="card">
      <div style="font-weight:900;margin-bottom:6px;">å¸¸è¦‹å•é¡Œ</div>
      <div class="help">
        ãƒ»LINE å…§å»ºç€è¦½å™¨å¯èƒ½ç„¡æ³•éŒ„éŸ³ï¼Œè«‹ã€Œåœ¨ç€è¦½å™¨é–‹å•Ÿã€ã€‚<br/>
        ãƒ»iPad/iPhone å»ºè­° Safari/Chrome æœ€æ–°ç‰ˆï¼Œä¸¦å…è¨±éº¥å…‹é¢¨æ¬Šé™ã€‚<br/>
        ãƒ»éŒ„éŸ³ç§’æ•¸å¤ªé•·æœƒå°è‡´æª”æ¡ˆå¤ªå¤§ï¼Œå»ºè­° 20ï½60 ç§’ã€‚<br/>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // GAS Web App /execï¼ˆä¿æŒä½ åŸæœ¬çš„ï¼‰
  const GAS_URL = "https://script.google.com/macros/s/AKfycbwK2iLgREG52ReX_CLUQdai-iiAUzDNubkRKhAXL03Gk4QjkbJe71IKQ4pFQLFAPlg/exec";
  const JSONP_SRC = () => `${GAS_URL}?api=getPublicConfig&callback=__onCfg&_=${Date.now()}`;

  // iPadOS 13+ æœƒå½è£æˆ MacIntel
  const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                 (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  // âœ… åªæ–°å¢ Android åˆ¤æ–·ï¼ˆå…¶é¤˜ä¸å‹•ï¼‰
  const IS_ANDROID = /Android/i.test(navigator.userAgent);

  // âœ… ç¶­æŒä½ ç›®å‰çš„éŸ³é‡ç­–ç•¥ï¼šiOS/é Android ä»é–‹å•Ÿè™•ç†ï¼›Android é—œæ‰é¿å… gating æ–·éŸ³
  const AUDIO_CONSTRAINTS = {
    channelCount: 1,
    echoCancellation: IS_ANDROID ? false : true,
    noiseSuppression: IS_ANDROID ? false : true,
    autoGainControl: IS_ANDROID ? false : true
  };

  let tasks = [];
  let selected = null;

  const elTitle = document.querySelector('#title');
  const elTask = document.querySelector('#taskSel');
  const elSeat = document.querySelector('#seatNo');
  const elName = document.querySelector('#stuName');
  const elBtn  = document.querySelector('#btn');
  const elStatus = document.querySelector('#status');

  const micDot = document.querySelector('#micDot');
  const micText = document.querySelector('#micText');

  const bar = document.querySelector('#bar');
  const t = document.querySelector('#t');

  const btnMicTest = document.querySelector('#micTest');
  const btnHelp = document.querySelector('#help');

  let recording = false;
  let durationTotal = 0;
  let timeLeft = 0;
  let timerId = null;

  // Wake Lock
  let wakeLock = null;
  let wantWakeLock = false;

  // WebAudio
  let mediaStream = null;
  let audioCtx = null;
  let srcNode = null;
  let workletNode = null;
  let procNode = null;
  let zeroGain = null;

  // PCM
  let pcmChunks = [];
  let pcmLength = 0;

  function setMicState(state, msg){
    micDot.classList.remove('ok','no','wait');
    if(state === 'ok') micDot.classList.add('ok');
    else if(state === 'no') micDot.classList.add('no');
    else micDot.classList.add('wait');
    micText.textContent = msg || 'éº¥å…‹é¢¨ç‹€æ…‹ï¼šåµæ¸¬ä¸­';
  }

  function setTimer(sec){
    const m = Math.floor(sec/60);
    const s = sec%60;
    t.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    const pct = durationTotal ? Math.max(0, Math.min(100, ((durationTotal-sec)/durationTotal)*100 )) : 0;
    bar.style.width = `${pct}%`;
  }

  function validInfo(){
    const seat = String(elSeat.value||'').trim();
    const name = String(elName.value||'').trim();
    if(!/^\d{1,2}$/.test(seat)) return false;
    if(Number(seat) < 1 || Number(seat) > 99) return false;
    if(name.length < 2) return false;
    return true;
  }

  function isExpired(task){
    if(!task || !task.deadline) return false;
    const ts = Date.parse(task.deadline);
    if(Number.isNaN(ts)) return false;
    return ts < Date.now();
  }

  function updateBtnState(){
    const ok = !!selected && validInfo() && !isExpired(selected);
    elBtn.disabled = !ok || recording;
  }

  function renderTaskOptions(){
    elTask.innerHTML = '';
    if(!tasks.length){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'ï¼ˆç›®å‰æ²’æœ‰é–‹æ”¾ä½œæ¥­ï¼‰';
      elTask.appendChild(opt);
      selected = null;
      durationTotal = 0; timeLeft = 0;
      setTimer(0);
      elStatus.innerHTML = `ç›®å‰æ²’æœ‰é–‹æ”¾ä½œæ¥­<span class="sub">è«‹ç¨å¾Œå†è©¦æˆ–è¯ç¹«è€å¸«ã€‚</span>`;
      updateBtnState();
      return;
    }

    tasks.forEach((x, idx)=>{
      const opt = document.createElement('option');
      opt.value = x.id;
      const expired = isExpired(x);
      const dl = x.deadline ? `ï½œæˆªæ­¢ï¼š${x.deadline}` : '';
      opt.textContent = `${x.title}${dl}${expired ? 'ï¼ˆå·²æˆªæ­¢ï¼‰' : ''}`;
      if(expired) opt.disabled = true;
      elTask.appendChild(opt);
      if(idx === 0 && !selected && !expired) selected = x;
    });

    if(selected && isExpired(selected)) selected = tasks.find(x => !isExpired(x)) || null;

    if(selected){
      elTask.value = selected.id;
      durationTotal = Number(selected.duration || 30);
      timeLeft = durationTotal;
      setTimer(timeLeft);
      elStatus.innerHTML = `è«‹å…ˆé¸æ“‡ä½œæ¥­ä¸¦å¡«åº§è™Ÿå§“å<span class="sub">å®Œæˆå¾ŒæŒ‰é–‹å§‹ã€‚</span>`;
    } else {
      durationTotal = 0; timeLeft = 0;
      setTimer(0);
      elStatus.innerHTML = `ç›®å‰ä½œæ¥­çš†å·²æˆªæ­¢<span class="sub">è«‹è¯ç¹«è€å¸«ã€‚</span>`;
    }
    updateBtnState();
  }

  elTask.addEventListener('change', ()=>{
    const id = elTask.value;
    selected = tasks.find(t=>t.id===id) || null;
    if(selected){
      durationTotal = Number(selected.duration || 30);
      timeLeft = durationTotal;
      setTimer(timeLeft);
      elStatus.innerHTML = `è«‹å…ˆé¸æ“‡ä½œæ¥­ä¸¦å¡«åº§è™Ÿå§“å<span class="sub">å®Œæˆå¾ŒæŒ‰é–‹å§‹ã€‚</span>`;
    }
    updateBtnState();
  });
  elSeat.addEventListener('input', updateBtnState);
  elName.addEventListener('input', updateBtnState);

  function showHelp(){
    alert(
`âœ… æ¬Šé™æ•™å­¸

ã€é›»è…¦ Chrome/Edgeã€‘
1) çœ‹ç¶²å€åˆ—å·¦é‚Šã€Œé–é ­ã€
2) éº¥å…‹é¢¨ â†’ å…è¨±
3) é‡æ–°æ•´ç†æœ¬é 

ã€iPhone / iPadã€‘
è¨­å®š â†’ Safariï¼ˆæˆ– Chromeï¼‰â†’ éº¥å…‹é¢¨ â†’ å…è¨±

ã€LINE å…§å»ºç€è¦½å™¨ã€‘
å¯èƒ½ç„¡æ³•éŒ„éŸ³ï¼Œè«‹ã€Œåœ¨ç€è¦½å™¨é–‹å•Ÿã€ã€‚`
    );
  }

  async function requestMicOnce(){
    try{
      setMicState('wait','éº¥å…‹é¢¨ç‹€æ…‹ï¼šè«‹æ±‚æ¬Šé™ä¸­â€¦');
      const st = await navigator.mediaDevices.getUserMedia({ audio: AUDIO_CONSTRAINTS });
      st.getTracks().forEach(tr=>tr.stop());
      setMicState('ok','éº¥å…‹é¢¨ç‹€æ…‹ï¼šå·²é–‹å•Ÿï¼ˆå¯éŒ„éŸ³ï¼‰');
      elStatus.innerHTML = `âœ… éº¥å…‹é¢¨æ­£å¸¸<span class="sub">ç¾åœ¨å¯ä»¥é–‹å§‹éŒ„éŸ³ã€‚</span>`;
    }catch(err){
      setMicState('no','éº¥å…‹é¢¨ç‹€æ…‹ï¼šæœªé–‹å•Ÿï¼ˆè«‹å…è¨±æ¬Šé™ï¼‰');
      elStatus.innerHTML = `âŒ éº¥å…‹é¢¨ä¸å¯ç”¨<span class="sub">${String(err && err.name ? err.name : err)}</span>`;
    }
  }

  function clearTimer(){
    if(timerId){ clearInterval(timerId); timerId=null; }
  }

  function startCountdown(autoStopFn){
    clearTimer();
    setTimer(timeLeft);
    timerId = setInterval(()=>{
      timeLeft--;
      if(timeLeft < 0) timeLeft = 0;
      setTimer(timeLeft);
      if(timeLeft <= 0){
        clearTimer();
        autoStopFn && autoStopFn();
      }
    }, 1000);
  }

  async function requestWakeLock(){
    try{
      if (!('wakeLock' in navigator)) return;
      if (document.visibilityState !== 'visible') return;
      wakeLock = await navigator.wakeLock.request('screen');
    }catch(e){}
  }

  function releaseWakeLock(){
    try{ if (wakeLock){ wakeLock.release(); wakeLock=null; } }catch(e){}
  }

  document.addEventListener('visibilitychange', async () => {
    if (!wantWakeLock) return;
    if (document.visibilityState === 'visible') await requestWakeLock();
  });

  function ensureAudioCtx(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }

  function stopAllAudio(){
    try{
      if (workletNode){ workletNode.port.onmessage=null; workletNode.disconnect(); workletNode=null; }
      if (procNode){ procNode.disconnect(); procNode.onaudioprocess=null; procNode=null; }
      if (srcNode){ srcNode.disconnect(); srcNode=null; }
      if (zeroGain){ zeroGain.disconnect(); zeroGain=null; }
    }catch(e){}
    try{ if (audioCtx) audioCtx.close && audioCtx.close(); }catch(e){}
    audioCtx = null;
    try{ if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; } }catch(e){}
  }

  function mergeFloat32(chunks, totalLen){
    const out = new Float32Array(totalLen);
    let off = 0;
    for (const c of chunks){ out.set(c, off); off += c.length; }
    return out;
  }

  function downsampleBuffer(buffer, inRate, outRate){
    if (outRate >= inRate) return buffer;
    const ratio = inRate / outRate;
    const newLen = Math.round(buffer.length / ratio);
    const result = new Float32Array(newLen);
    let offsetRes = 0;
    let offsetBuf = 0;
    while (offsetRes < result.length){
      const nextOffsetBuf = Math.round((offsetRes + 1) * ratio);
      let sum = 0, count = 0;
      for (let i = offsetBuf; i < nextOffsetBuf && i < buffer.length; i++){ sum += buffer[i]; count++; }
      result[offsetRes] = count ? (sum / count) : 0;
      offsetRes++;
      offsetBuf = nextOffsetBuf;
    }
    return result;
  }

  // ç¶­æŒåŸæœ¬éŸ³é‡ï¼ˆå³°å€¼æ‹‰åˆ° 0.98ï¼Œåªæ”¾å¤§ä¸ç¸®å°ï¼‰
  function normalizePeak(samples){
    let mean = 0;
    for(let i=0;i<samples.length;i++) mean += samples[i];
    mean /= Math.max(1, samples.length);
    for(let i=0;i<samples.length;i++) samples[i] -= mean;

    let peak = 0;
    for(let i=0;i<samples.length;i++){
      const a = Math.abs(samples[i]);
      if(a>peak) peak=a;
    }
    if(!peak || peak < 1e-6) return samples;

    const TARGET = 0.98;
    const MAX_GAIN = 80;
    let gain = TARGET / peak;
    if (gain < 1) gain = 1;
    if (gain > MAX_GAIN) gain = MAX_GAIN;

    for(let i=0;i<samples.length;i++){
      let v = samples[i] * gain;
      if (v > 0.995) v = 0.995;
      if (v < -0.995) v = -0.995;
      samples[i] = v;
    }
    return samples;
  }

  function floatTo16BitPCM(float32){
    const out = new Int16Array(float32.length);
    for (let i = 0; i < float32.length; i++){
      let s = Math.max(-1, Math.min(1, float32[i]));
      out[i] = (s < 0 ? s * 0x8000 : s * 0x7FFF) | 0;
    }
    return out;
  }

  function writeString(view, offset, str){
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  }

  function encodeWavPCM(samples16, sampleRate){
    const numChannels = 1;
    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = samples16.length * bytesPerSample;

    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');

    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);

    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i = 0; i < samples16.length; i++, offset += 2){
      view.setInt16(offset, samples16[i], true);
    }
    return buffer;
  }

  function blobToBase64(blob){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = () => {
        const s = String(fr.result||'');
        const idx = s.indexOf('base64,');
        resolve(idx >= 0 ? s.slice(idx+7) : s);
      };
      fr.onerror = reject;
      fr.readAsDataURL(blob);
    });
  }

  function makeToken(){
    try{ if (crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(e){}
    return 't' + Date.now() + '_' + Math.random().toString(16).slice(2);
  }

  async function initWorklet(){
    if (!audioCtx || !audioCtx.audioWorklet) return false;
    const workletCode = `
      class PcmCapture extends AudioWorkletProcessor {
        constructor(){
          super();
          this._bufs = [];
          this._len = 0;
          this._target = 2048;
          this.port.onmessage = (e)=>{
            const d = e.data || {};
            if(d.cmd === 'flush') this._flush();
          };
        }
        _flush(){
          if(!this._len) return;
          const out = new Float32Array(this._len);
          let off = 0;
          for(const b of this._bufs){ out.set(b, off); off += b.length; }
          this._bufs = [];
          this._len = 0;
          this.port.postMessage(out, [out.buffer]);
        }
        process(inputs){
          const input = inputs[0] && inputs[0][0];
          if(input && input.length){
            const c = new Float32Array(input.length);
            c.set(input);
            this._bufs.push(c);
            this._len += c.length;
            if(this._len >= this._target) this._flush();
          }
          return true;
        }
      }
      registerProcessor('pcm-capture', PcmCapture);
    `;
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    return true;
  }

  async function startRecordingAndSubmit(){
    if(!selected){ elStatus.innerHTML = `âŒ è«‹å…ˆé¸æ“‡ä½œæ¥­`; return; }
    if(isExpired(selected)){ elStatus.innerHTML = `âŒ ä½œæ¥­å·²æˆªæ­¢`; return; }
    if(!validInfo()){
      elStatus.innerHTML = `âŒ è«‹æ­£ç¢ºå¡«å¯«åº§è™Ÿèˆ‡å§“å<span class="sub">åº§è™Ÿ 1ï½99ã€å§“åè‡³å°‘ 2 å€‹å­—ã€‚</span>`;
      return;
    }

    try{
      wantWakeLock = true;
      await requestWakeLock();

      setMicState('wait','éº¥å…‹é¢¨ç‹€æ…‹ï¼šéŒ„éŸ³æº–å‚™ä¸­â€¦');
      elStatus.innerHTML = `ğŸ™ï¸ éŒ„éŸ³æº–å‚™ä¸­â€¦<span class="sub">è«‹å…è¨±éº¥å…‹é¢¨æ¬Šé™ã€‚</span>`;

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: AUDIO_CONSTRAINTS });

      ensureAudioCtx();
      pcmChunks = []; pcmLength = 0;

      srcNode = audioCtx.createMediaStreamSource(mediaStream);
      zeroGain = audioCtx.createGain();
      zeroGain.gain.value = 0;

      let useWorklet = false;
      try{ useWorklet = await initWorklet(); }catch(e){ useWorklet = false; }

      if(useWorklet){
        workletNode = new AudioWorkletNode(audioCtx, 'pcm-capture');
        workletNode.port.onmessage = (ev)=>{
          const chunk = ev.data;
          if(chunk && chunk.length){ pcmChunks.push(chunk); pcmLength += chunk.length; }
        };
        srcNode.connect(workletNode);
        workletNode.connect(zeroGain);
      } else {
        const bufSize = 16384;
        procNode = audioCtx.createScriptProcessor(bufSize, 1, 1);
        procNode.onaudioprocess = (ev)=>{
          const input = ev.inputBuffer.getChannelData(0);
          const copy = new Float32Array(input.length);
          copy.set(input);
          pcmChunks.push(copy);
          pcmLength += copy.length;
        };
        srcNode.connect(procNode);
        procNode.connect(zeroGain);
      }

      zeroGain.connect(audioCtx.destination);

      setMicState('ok','éº¥å…‹é¢¨ç‹€æ…‹ï¼šéŒ„éŸ³ä¸­');
      recording = true;
      updateBtnState();

      durationTotal = Number(selected.duration||30);
      timeLeft = durationTotal;
      setTimer(timeLeft);

      elStatus.innerHTML = `ğŸ”´ æ­£åœ¨éŒ„éŸ³â€¦<span class="sub">å€’æ•¸çµæŸæœƒè‡ªå‹•åœæ­¢ä¸¦é€å‡ºã€‚</span>`;

      startCountdown(async ()=>{
        try{
          recording = false;
          updateBtnState();
          clearTimer();

          setMicState('wait','éº¥å…‹é¢¨ç‹€æ…‹ï¼šè™•ç†éŸ³æª”ä¸­â€¦');
          elStatus.innerHTML = `ğŸ§¾ ç”¢ç”ŸéŸ³æª”ä¸­â€¦<span class="sub">å®Œæˆå¾Œæœƒè‡ªå‹•é€å‡ºä¸¦è·³å›åŸ·é ã€‚</span>`;

          const inRate = audioCtx.sampleRate;

          if(workletNode){
            try{ workletNode.port.postMessage({ cmd:'flush' }); }catch(e){}
            await new Promise(r=>setTimeout(r, 80));
          }

          try{
            if (srcNode) srcNode.disconnect();
            if (procNode){ procNode.onaudioprocess = null; procNode.disconnect(); }
            if (workletNode) workletNode.disconnect();
            if (zeroGain) zeroGain.disconnect();
          }catch(e){}

          const merged = mergeFloat32(pcmChunks, pcmLength);
          let down = downsampleBuffer(merged, inRate, 16000);
          down = normalizePeak(down);
          const pcm16 = floatTo16BitPCM(down);
          const wavBuf = encodeWavPCM(pcm16, 16000);
          const wavBlob = new Blob([wavBuf], { type: 'audio/wav' });
          const b64 = await blobToBase64(wavBlob);

          stopAllAudio();

          setMicState('wait','éº¥å…‹é¢¨ç‹€æ…‹ï¼šé€å‡ºä¸­â€¦');
          elStatus.innerHTML = `â« é€å‡ºä¸­â€¦<span class="sub">è«‹ç¨å€™ï¼Œå°‡é¡¯ç¤ºå›åŸ·é ã€‚</span>`;

          const token = makeToken();
          const payload = {
            token,
            taskId: selected.id,
            seatNo: String(elSeat.value||'').trim(),
            studentName: String(elName.value||'').trim(),
            type: 'audio/wav',
            base64: b64
          };

          await fetch(`${GAS_URL}?api=uploadV2`, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(payload)
          });

          wantWakeLock = false;
          releaseWakeLock();

          location.href = `${GAS_URL}?page=receipt&token=${encodeURIComponent(token)}`;

        }catch(err){
          wantWakeLock = false;
          releaseWakeLock();
          stopAllAudio();
          setMicState('no','éº¥å…‹é¢¨ç‹€æ…‹ï¼šé€å‡ºå¤±æ•—');
          elStatus.innerHTML = `âŒ é€å‡ºå¤±æ•—<span class="sub">${String(err && err.message ? err.message : err)}</span>`;
          recording = false;
          updateBtnState();
        }
      });

    }catch(err){
      wantWakeLock = false;
      releaseWakeLock();
      stopAllAudio();
      clearTimer();
      setMicState('no','éº¥å…‹é¢¨ç‹€æ…‹ï¼šæœªé–‹å•Ÿï¼ˆè«‹å…è¨±æ¬Šé™ï¼‰');
      elStatus.innerHTML = `âŒ ç„¡æ³•é–‹å§‹éŒ„éŸ³<span class="sub">${String(err && err.name ? err.name : err)}</span>`;
      recording = false;
      updateBtnState();
    }
  }

  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    setMicState('no','éº¥å…‹é¢¨ç‹€æ…‹ï¼šæ­¤ç€è¦½å™¨ä¸æ”¯æ´');
    elStatus.innerHTML = `âŒ ä½ çš„ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³<span class="sub">è«‹æ”¹ç”¨ Chrome / Edge / Safari æœ€æ–°ç‰ˆã€‚</span>`;
  } else {
    setMicState('wait','éº¥å…‹é¢¨ç‹€æ…‹ï¼šå°šæœªæˆæ¬Šï¼ˆå¯å…ˆæ¸¬è©¦ï¼‰');
  }

  btnMicTest.addEventListener('click', requestMicOnce);
  btnHelp.addEventListener('click', showHelp);
  elBtn.addEventListener('click', ()=>{ if(recording) return; startRecordingAndSubmit(); });

  window.__onCfg = (cfg) => {
    elTitle.textContent = (cfg && cfg.title) ? cfg.title : 'éŒ„éŸ³ä½œæ¥­';
    tasks = (cfg && cfg.tasks) ? cfg.tasks : [];
    selected = null;
    renderTaskOptions();
  };

  (function loadJsonp(){
    const s = document.createElement('script');
    s.src = JSONP_SRC();
    s.onerror = () => {
      elStatus.innerHTML = `âŒ è¼‰å…¥ä½œæ¥­å¤±æ•—<span class="sub">è«‹ç¢ºèª GAS_URL æ­£ç¢ºã€ä¸”éƒ¨ç½²ç‚ºä»»ä½•äººå¯å­˜å–ã€‚</span>`;
    };
    document.body.appendChild(s);
  })();

})();
</script>
</body>
</html>
